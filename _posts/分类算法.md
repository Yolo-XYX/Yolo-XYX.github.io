###### 滑动窗口

```
适用情况：一般是对于连续的子数组或者连续得到字符串，这里不能是子序列，因为子序列可选可不选，因此必须是连续的，同时我们要复用相关的结果，也就是结果集要保留，这样可以减少相关的计算
```



```java
1.定长滑动窗口
模板：1456.定长字串中元音的最大数目
思路：只要是滑动窗口类型的题目，最外层使用for循环控制右边界，然后while循环控制左边界，这里由于是定长滑动窗口，因此这里还需要先考虑一下窗口的大小是否已经达到了预定值，如果没有达到，不进行处理直接进行下次for循环，由于定长滑动窗口比较特殊，for循环中没有while循环，因为当窗口正好的时候，接下来就要改变窗口大小了，只需要改变一次，因此不要用循环。
class Solution {
    public int maxVowels(String s, int k) {
        int n = s.length();
        int left = 0, res = 0;
        int sum = 0;
        for (int right = 0; right < n; right++) {
            char c = s.charAt(right);
            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {
                sum++;
            }
            if (right + 1 < k) {
                // 滑动窗口太小
                continue;
            }
            res = Math.max(res, sum);
            char out = s.charAt(left);
            if (out == 'a' || out == 'e' || out == 'i' || out == 'o' || out == 'u') {
                sum--;
            }
            left++;
        }
        return res;
    }
}
```



```java
2.不定长滑动窗口
模板：209.长度最小的子数组
思路：思路和定长滑动窗口相似，都是使用两个变量维护滑动窗口，分别是left,right,但是对于right直接在最外层的for循环中进行定义即可，对于left需要提前定义;最大的区别在于for循环内部还要有一个while循环保持保持移动左边窗口位置，因为是变长的所以有while循环
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int n = nums.length;
        int ans = n + 1;
        int sum = 0; // 子数组元素和
        int left = 0; // 子数组左端点
        for (int right = 0; right < n; right++) { // 枚举子数组右端点
            sum += nums[right];
            while (sum >= target) { // 满足要求
                ans = Math.min(ans, right - left + 1);
                sum -= nums[left++]; // 左端点右移
            }
        }
        return ans <= n ? ans : 0;
    }
}

01.求最长/最大不定滑动窗口
模板：3.无重复字符串的最长字串
思路：这里是求最长字串问题，因为while循环主要是进行不符合条件的时候左指针的移动，对于符合条件的每次都会进行计算
class Solution {
    public int lengthOfLongestSubstring(String S) {
        char[] s = S.toCharArray(); // 转换成 char[] 加快效率（忽略带来的空间消耗）
        int n = s.length;
        int ans = 0;
        int left = 0;
        boolean[] has = new boolean[128]; // 也可以用 HashSet<Character>，这里为了效率用的数组
        for (int right = 0; right < n; right++) {
            char c = s[right];
            // 如果窗口内已经包含 c，那么再加入一个 c 会导致窗口内有重复元素
            // 所以要在加入 c 之前，先移出窗口内的 c
            while (has[c]) { // 窗口内有 c
                has[s[left++]] = false; // 缩小窗口
            }
            has[c] = true; // 加入 c
            ans = Math.max(ans, right - left + 1); // 更新窗口长度最大值
        }
        return ans;
    }
}

02.求最短/最小
模板：1234.替换子串得到平衡字符串
思路：这里由于是求最小的子数组，因此这里在符合条件的前提下，需要不断缩小left和right之间的距离，也就是在while循环中左这个事情，因此while循环中是符合要求的，因此这里在while循环中取值，以后最小的都是在while循环中取值。
class Solution {
    public int balancedString(String s) {
        int n=s.length(),left=0;
        int ans=n,m=n/4;
        int[] count=new int['X'];
        for(int i=0;i<n;i++){
            char c=s.charAt(i);
            count[c]++;
        }
        if(count['Q']==m&&count['W']==m&&count['E']==m&&count['R']==m) return 0;
        for(int right=0;right<n;right++){
            char c=s.charAt(right);
            count[c]--;
            while(count['Q']<=m&&count['W']<=m&&count['E']<=m&&count['R']<=m){
                ans=Math.min(ans,right-left+1);
                char cl=s.charAt(left);
                count[cl]++;
                left++;
            }
        }
        return ans;
    }
}


03.求子数组个数
①越长越合法：也就是没有限制数组长度，那么小的子数组符合那么大的子数组也是符合的
模板：1358. 包含所有三种字符的子字符串数目
思路：一般要写 ans += left。滑动窗口的内层循环结束时，右端点固定在 right，左端点在0,1,2,⋯,left−1 的所有子数组（子串）都是合法的，这一共有 left个。
class Solution {
    public int numberOfSubstrings(String s) {
        int n = s.length();
        int left = 0, ans = 0;
        int[] cnt = new int[3];
        for (int right = 0; right < n; right++) {
            cnt[s.charAt(right) - 'a']++;
            while (cnt[0] >= 1 && cnt[1] >= 1 && cnt[2] >= 1) {
                cnt[s.charAt(left) - 'a']--;
                left++;
            }
            ans += left;
        }
        return ans;
    }
}
//注：这里也就是left左边的都是合法的

②越短越合法：滑动窗口内的都满足，那么比他更小的肯定也满足
模板：2302. 统计得分小于 K 的子数组数目
思路：一般要写 ans += right - left + 1。滑动窗口的内层循环结束时，右端点固定在right，左端点在 left,
left+1,⋯,right的所有子数组
class Solution {
    public long countSubarrays(int[] nums, long k) {
        int left = 0, n = nums.length;
        long ans = 0, sum = 0;
        for (int right = 0; right < n; right++) {
            sum += nums[right];
            while (sum * (right - left + 1) >= k) {
                sum -= nums[left];
                left++;
            }
            ans += right - left + 1;
        }
        return ans;
    }
}

③恰好型滑动窗口
模板：930. 和相同的二元子数组
思路：例如，要计算有多少个元素和恰好等于k的子数组，可以把问题变成：计算有多少个元素和 ≥𝑘的子数组。
计算有多少个元素和 >𝑘，也就是≥𝑘+1的子数组。
答案就是元素和 ≥𝑘的子数组个数，减去元素和≥k+1 的子数组个数。这里把 > 转换成≥，从而可以把滑窗逻辑封装成一个函数 f，然后用 f(k) - f(k + 1) 计算，无需编写两份滑窗代码。
总结：「恰好」可以拆分成两个「至少」，也就是两个「越长越合法」的滑窗问题。
注：也可以把问题变成 ≤k 减去 ≤k−1（两个至多）。可根据题目选择合适的变形方式。
class Solution {
    public int numSubarraysWithSum(int[] nums, int goal) {
        // 直接使用滑动窗口进行求解,但是由于是恰好型因此需要求两个最大
        // >=goal 和>=goal+1
        return window(nums, goal) - window(nums, goal + 1);
    }

    public int window(int[] nums, int goal) {
        int left = 0, ans = 0, n = nums.length, sum = 0;
        for (int right = 0; right < n; right++) {
            sum += nums[right];
            while (left <= right && sum >= goal) {
                sum -= nums[left];
                left++;
            }
            ans += left;
        }
        return ans;
    }
}
//注：此类型的题目也可以使用前缀和求解
```





```java
3.单序列双指针
01.相向双指针
模板：1750. 删除字符串两端相同字符后的最短长度
思路：两个指针eft=0, right=n−1，从数组的两端开始，向中间移动，这叫相向双指针。上面的滑动窗口相当于同向双指针。
class Solution {
    public int minimumLength(String s) {
        int n = s.length();
        int left = 0, right = n - 1;
        while (left < right && s.charAt(left) == s.charAt(right)) {
            char c = s.charAt(left);
            while (left <= right && s.charAt(left) == c) {
                left++;
            }
            while (left <= right && s.charAt(right) == c) {
                right--;
            }
        }
        return right - left + 1;
    }
}

02.同向双指针
两个指针的移动方向相同（都向右，或者都向左）
    
03.背向双指针
模板：1793. 好子数组的最大分数
思路：两个指针从数组中的同一个位置出发，一个向左，另一个向右，背向移动。
class Solution {
    public int maximumScore(int[] nums, int k) {
        // 使用双指针
        int left = k, right = k, ans = nums[k], minH = nums[k], n = nums.length;
        for (int i = 0; i < n - 1; i++) {
            if (right == n - 1 || (left > 0 && nums[right + 1] < nums[left - 1])) {
                left--;
                minH = Math.min(minH, nums[left]);
            } else {
                right++;
                minH = Math.min(minH, nums[right]);
            }
            ans = Math.max(ans, (right - left + 1) * minH);
        }
        return ans;
    }
}

04.原地修改
模板：905. 按奇偶排序数组
思路：根据题目条件使用双指针进行修改
class Solution {
    public int[] sortArrayByParity(int[] nums) {
        // 使用双指针进行修改
        int left = 0, right = nums.length - 1;
        while (left < right) {
            while (left < right && nums[left] % 2 == 0)
                left++;
            while (left < right && nums[right] % 2 == 1)
                right--;
            // 开始交换
            int temp = nums[left];
            nums[left] = nums[right];
            nums[right] = temp;
        }
        return nums;
    }
}
```



```java
4.双序列双指针
01.双指针
模板：1855. 下标对中的最大距离
思路：使用双指针，由于有两个序列，因此一个指针在序列1，一个指针在序列2，这样根据一个序列移动另外一个序列
class Solution {
    public int maxDistance(int[] nums1, int[] nums2) {
        int n1 = nums1.length, n2 = nums2.length;
        int top1 = 0, top2 = 0, ans = 0;
        while (top1 < n1 && top2 < n2) {
            int num = nums1[top1];
            while (top2 < n2 && nums2[top2] >= num) {
                top2++;
            }
            ans = Math.max(ans, top2 - top1 - 1);
            top1++;
        }
        return ans;
    }
}
//注：对于双指针问题比较灵活，因此有些指针并不是规则从头到尾进行移动的

02.判断子序列
模板：1023. 驼峰式匹配
思路：判断是否是子序列，让长的一方移动当不符合的时候，短的一个子序列符合的时候都移动
class Solution {
    public List<Boolean> camelMatch(String[] queries, String pattern) {
        int n = queries.length;
        List<Boolean> res = new ArrayList<Boolean>();
        for (int i = 0; i < n; i++) {
            boolean flag = true;
            int p = 0;
            for (int j = 0; j < queries[i].length(); j++) {
                char c = queries[i].charAt(j);
                if (p < pattern.length() && pattern.charAt(p) == c) {
                    p++;
                } else if (Character.isUpperCase(c)) {
                    flag = false;
                    break;
                }
            }
            if (p < pattern.length()) {
                flag = false;
            }
            res.add(flag);
        }
        return res;
    }
}


03.三指针
模板：795. 区间子数组个数
思路：相当于固定一个位置，然后判断其余两个指针所在的位置是否需要进行移动问题
class Solution {
    public int numSubarrayBoundedMax(int[] nums, int left, int right) {
        int ans=0,last0=-1,last1=-1;
        for(int i=0;i<nums.length;i++){
            if(nums[i]>right){
                last0=i;
                last1=-1;
            }
            else if(nums[i]>=left) last1=i;
            if(last1!=-1){
                ans+=last1-last0;
            }
        }
        return ans;
    }
}
```









```java
5.二分查找
适用题型：二分查找适用于找出某个值，最大值或者最小值(这里面可能会出现范围问题，找出一个值大于整体范围或者小于整体范围问题)
01.总篇
模板：744. 寻找比目标字母大的最小字母
思路：对于二分查找需要弄清楚区间问题，以及边界条件，这里下面使用了两个开区间也就是(left,right)，那么在查找的过程中，两个边界是不能使用的，因此while条件必须要至少区间中有一个数据，所以是left+1<right；这里对于左右指针的移动没有要求，因为这里最后返回的结果是看等于号在那一边，就返回那一边就可以了
class Solution {
    public char nextGreatestLetter(char[] letters, char target) {
        // 使用二分查找求解
        int left = -1, right = letters.length;
        while (left + 1 < right) {
            int mid = (left + right) / 2;
            if (letters[mid] <= target) {
                left = mid;
            } else {
                right = mid;
            }
        }
        return right == letters.length ? letters[0] : letters[right];
    }
}

02.求最小问题
模板：1283. 使结果不超过阈值的最小除数
思路：由于是求最小问题，左边是不满足的，也就是右边都是满足的，但是右边的数据不能太大，因此对于符合要求的，我们都是让他尽可能缩小范围让right=mid
class Solution {
    public int smallestDivisor(int[] nums, int threshold) {
        // 使用二分查找直接进行求解
        Arrays.sort(nums);
        int left = 0, right = nums[nums.length - 1] + 1;
        while (left + 1 < right) {
            int mid = left + (right - left) / 2;
            int res = getRes(nums, mid);
            if (res <= threshold) {
                right = mid;
            } else {
                left = mid;
            }
        }
        return right;
    }
    public int getRes(int[] nums, int num) {
        int ans = 0;
        for (int i = 0; i < nums.length; i++) {
            ans += (nums[i] + num - 1) / num;
        }
        return ans;
    }
}

03.求最大问题
模板：2226. 每个小孩最多能分到多少糖果
思路：求最大：check(mid) == true 时更新 left = mid，反之更新 right = mid，最后返回 left。关于求最大问题，这里由于是求最大的，因此这里当条件符合的时候就让范围中的结果变得更大
class Solution {
    public int maximumCandies(int[] candies, long k) {
        // 直接使用二分查找进行求解
        int left = 0, right = candies[0];
        for (int i = 0; i < candies.length; i++) {
            right = Math.max(candies[i], right);
        }
        right++;
        while (left + 1 < right) {
            int mid = left + (right - left) / 2;
            if (getCandies(candies, k, mid)) {
                left = mid;
            } else {
                right = mid;
            }
        }
        return left;
    }

    public Boolean getCandies(int[] candies, long k, int candy) {
        long child = 0;
        for (int i = 0; i < candies.length; i++) {
            child += candies[i] / candy;
        }
        return child >= k;
    }
}
```





```java
6.单调栈
01.普通单调栈
模板：739. 每日温度
思路：这里使用单调栈的思想，使单调栈从栈底最高栈顶最小，也就是降序顺序的，单调栈的本质就是只存储那些符合要求的，要让栈中的顺序得到满足，如果不满足就出栈操作就可以了，出战之后还要保持这种顺序
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int n = temperatures.length;
        int[] ans = new int[n];
        Deque<Integer> st = new ArrayDeque<>();
        for (int i = n - 1; i >= 0; i--) {
            int t = temperatures[i];
            while (!st.isEmpty() && t >= temperatures[st.peek()]) {
                st.pop();
            }
            if (!st.isEmpty()) {
                ans[i] = st.peek() - i;
            }
            st.push(i);
        }
        return ans;
    }
}

02.矩形面积
模板：84. 柱状图中最大的矩形
思路：这里求解的矩形面积中，肯定使数组中的某个元素高度，也就是矩形的高是以某个元素的高度为基准的，因此求解的时候逐个遍历每一个元素然后求解矩形面积；但是如何知道矩形的宽度呢，可以使用单调队列进行提前统计，也就是统计左边和右边比他高的元素有多少个
class Solution {
    public int largestRectangleArea(int[] heights) {
        int n = heights.length, ans = 0;
        int[] left = new int[n];
        int[] right = new int[n];
        Deque<Integer> stack = new ArrayDeque<>();
        for (int i = 0; i < n; i++) {
            int x = heights[i];
            while (!stack.isEmpty() && x <= heights[stack.peek()]) {
                stack.pop(); // 出队，表明此元素可用组成矩形
            }
            left[i] = stack.isEmpty() ? -1 : stack.peek();
            stack.push(i);
        }
        stack.clear();
        for (int i = n - 1; i >= 0; i--) {
            int x = heights[i];
            while (!stack.isEmpty() && x <= heights[stack.peek()]) {
                stack.pop();
            }
            right[i] = stack.isEmpty() ? n : stack.peek();
            stack.push(i);
        }
        for (int i = 0; i < n; i++) {
            ans = Math.max(ans, heights[i] * (right[i] - left[i] - 1));
        }
        return ans;
    }
}



04.最小字典序列
模板：1673. 找出最具竞争力的子序列
思路：这里由于是求最小子序列，因此要保证的就是前面的数字是最小的，因此可以使用一个单调栈也就是递增的，但是要保证最后的数据量有k个，这个时候就需要在出队的时候进行判断，对于剩余数据有k的前提下，前面是可以出栈的，因为前面越小整体就越小，也就是在前面尽量满足优先出栈
class Solution {
    public int[] mostCompetitive(int[] nums, int k) {
        int[] res = new int[k];
        int m = 0, n = nums.length;
        for (int i = 0; i < n; i++) {
            int x = nums[i];
            while (m > 0 && res[m - 1] > x && (m + n - i) > k) {
                m--;
            }
            if (m < k)
                res[m++] = x;
        }
        return res;
    }
}
```





```java
7.网格图
01.DFS
模板：200. 岛屿数量
思路：使用深度优先遍历，其实和二叉树的深度优先遍历一样，遍历每个左右子树，这里需要遍历的就是他的上下左右四个方向，在遍历的过程中需要首先进行判断当前是否超出边界，也就是在深度优先遍历的函数中进行遍历，这样能降低代码复杂度，同时便于理解问题
class Solution {
    public int numIslands(char[][] grid) {
        int count = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == '1') {
                    dfs(grid, i, j);
                    count++;
                }
            }
        }
        return count;
    }

    private void dfs(char[][] grid, int i, int j) {
        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length||grid[i][j] == '0')
            return;
        grid[i][j] = '0';
        dfs(grid, i + 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i - 1, j);
        dfs(grid, i, j - 1);
    }
}

模板：827. 最大人工岛
思路：这里是岛屿面积问题，因此这里需要有返回值进行统计，因此深度优先遍历需要返回值进行累加获得面积
class Solution {
    private static final int[][] DIRS = new int[][] { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };

    public int largestIsland(int[][] grid) {
        /** 整体思路是先通过深度优先遍历统计出各个岛屿的面积，然后进行逐个遍历水区，看是否能和四个方向的岛屿连接起来，如果可以那么面积就是加起来的和 */
        List<Integer> area = new ArrayList<>();
        int ans = 0, n = grid.length;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    area.add(dfs(grid, i, j, area.size() + 2));
                }
            }
        }
        if (area.isEmpty())
            return 1;
        // 遍历完之后开始遍历水区
        Set<Integer> set = new HashSet<>();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                set.clear();
                if (grid[i][j] != 0) {
                    continue;
                }
                int newArea = 1;
                for (int[] dir : DIRS) {
                    int x = i + dir[0];
                    int y = j + dir[1];
                    if (x >= 0 && x < n && y >= 0 && y < n && grid[x][y] != 0 && set.add(grid[x][y])) {
                        newArea += area.get(grid[x][y] - 2);
                    }
                }
                ans = Math.max(ans, newArea);
            }
        }
        return ans == 0 ? n * n : ans;
    }

    private int dfs(int[][] grid, int i, int j, int id) {
        if (i < 0 || i >= grid.length || j < 0 || j >= grid.length || grid[i][j] != 1) {
            return 0;
        }
        int size = 1;
        grid[i][j] = id;
        // 遍历上下左右四个方向
        for (int[] dir : DIRS) {
            int x = i + dir[0];
            int y = j + dir[1];
            size += dfs(grid, x, y, id);
        }
        return size;
    }
}

模板：695.岛屿的最大面积
思路：对于深搜有返回值的，也是可以直接使用下面的方法进行处理的
public int maxAreaOfIsland(int[][] grid) {
    if (grid.length == 0 || grid[0].length == 0) {
        return 0;
    }

    int res = 0;
    for (int r = 0; r < grid.length; r++) {
        for (int c = 0; c < grid[0].length; c++) {
            if (grid[r][c] == 1) {
                int a = area(grid, r, c);
                res = Math.max(res, a);
            }
        }
    }
    return res;
}

int area(int[][] grid, int r, int c) {
    if (!(0 <= r && r < grid.length 
          && 0 <= c && c < grid[0].length)) {
        return 0;
    }
    if (grid[r][c] != 1) {
        return 0;
    }
    grid[r][c] = 2;
    return 1 
        + area(grid, r - 1, c)
        + area(grid, r + 1, c)
        + area(grid, r, c - 1)
        + area(grid, r, c + 1);
}


02.BFS
模板：1091. 二进制矩阵中的最短路径
思路：使用队列进行遍历，对于每一次出队操作，要把同一批次进入队列的所有元素都都出栈，因此使用循环操作出栈所有的元素，每次出栈一次就相当于距离+1
class Solution {
    public int shortestPathBinaryMatrix(int[][] grid) {
        int[][] DIRS = new int[][] { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 }, { -1, -1 }, { -1, 1 }, { 1, -1 },
                { 1, 1 } };
        int n = grid.length, ans = 0;
        if (grid[0][0] == 1 || grid[n - 1][n - 1] == 1)
            return -1;
        Deque<int[]> queue = new ArrayDeque<>();
        queue.offer(new int[] { 0, 0 });
        grid[0][0] = 1;
        while (!queue.isEmpty()) {
            int size = queue.size();
            ans++;
            System.out.println("size:" + size);
            for (int i = 0; i < size; i++) {
                int[] poll = queue.poll();
                int x = poll[0], y = poll[1];
                // 把该节点的上下左右四个方向的全部加入进去
                if (x == n - 1 && y == n - 1)
                    return ans;
                System.out.println(x + ",--" + y + "," + ans);
                for (int[] dir : DIRS) {
                    int newX = x + dir[0], newY = dir[1] + y;

                    if (newX >= 0 && newX < n && newY >= 0 && newY < n && grid[newX][newY] == 0) {
                        System.out.println(newX + "," + newY);
                        queue.offer(new int[] { newX, newY });
                        grid[newX][newY] = 1;
                    }
                }
            }
        }
        return -1;
    }
}
```







```java
8.位运算
01.异或（XOR）的性质
模板：2588. 统计美丽子数组数目
思路：这里如果相同位可以减去，意思就是异或的结果，但是求的是子数组，如果进行挨个遍历的话会超时，因此这里使用前缀和的方式进行统计好结果然后再进行遍历，也就是统计好前面所有的异或和，那么这个时候如果要求中间的子数组的话，就可以直接前面总的异或后面总的，这个时候就是中间的子数组了，那么中间子数组为0，也就是说后面的和前面的相等才可以让结果为0，所以我们就可以直接统计前缀和相等的个数即可，因此这里使用哈希进行统计
class Solution {
    public long beautifulSubarrays(int[] nums) {
        long ans = 0;
        int n = nums.length;
        int[] pre = new int[n + 1];
        pre[0] = 0;
        for (int i = 1; i <= n; i++) {
            pre[i] = pre[i - 1] ^ nums[i - 1];
        }
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i <= n; i++) {
            ans += map.getOrDefault(pre[i], 0);
            map.put(pre[i], map.getOrDefault(pre[i], 0) + 1);
        }
        return ans;
    }
}

02.与运算
模板：2871. 将数组分割成最多数目的子数组
思路：这里由于是与运算，因此就是与的数据越多，肯定数字会尽可能小的，不会递增的，因此这里所有数字的与运算肯定是最小的也就是子数组之后最小，因此对于所有的子数组都必须是0，否则的话都会大于的，所以如果所有数组与操作
class Solution {
    public int maxSubarrays(int[] nums) {
        int ans = 0, res = -1;
        for (int i = 0; i < nums.length; i++) {
            res = res & nums[i];
            if (res == 0) {
                ans++;
                res = -1;
            }
        }
        return Math.max(ans, 1);
    }
}

03.或运算
模板：2680. 最大或值
思路：这里使用前缀和+或运算；要想数据最大，就要选择移动最高位的1的那个数，才会让总和最大，那么如果有多个最高位的1的数，那就需要进行遍历进行确认了，因此就有了下面的循环遍历
class Solution {
    public long maximumOr(int[] nums, int k) {
        // 注：这里尝试让每一个元素尝试移动k位进行操作
        int n = nums.length;
        long[] suf = new long[n + 1];
        long pre = 0, ans = 0;
        for (int i = n - 1; i >= 0; i--) {
            suf[i] = suf[i + 1] | nums[i];
        }
        for (int i = 0; i < n; i++) {
            ans = Math.max(ans, pre | ((long) nums[i] << k) | suf[i + 1]);
            pre = pre | nums[i];
        }
        return ans;
    }
}

04.拆位/贡献法
模板：2275. 按位与结果大于零的最长组合
思路：这里要求的是按位与运算结果不为0，那就要求与之后至少有一位不为0，因此这里只需要统计数字中某个位数上1的最多的数字，因为只要出现了0，就会造成结果为0
class Solution {
    public int largestCombination(int[] candidates) {
        int ans = 0;
        for (int i = 0; i < 32; i++) {
            int sum = 0;
            for (int j = 0; j < candidates.length; j++) {
                sum += (candidates[j] >> i) & 1;
            }
            ans = Math.max(ans, sum);
        }
        return ans;
    }
}

05.恒等式
模板：1835. 所有数对按位与结果的异或和
思路：这里是求两个数组的所有元素两两与之后再求异或，那这个时候对于与操作的话，只有两者全部为1的时候才是1，同时对于异或来说的话，只有结果有奇数个1最后结果才是1，不然的话偶数个1最后结果还是0，因此这个时候就要看与之后有多少个1，那就看每个数组中1的个数，因此求出数组1中的个数乘以数组二中的个数，即可得到最后又多少个1
class Solution {
    public int getXORSum(int[] arr1, int[] arr2) {
        int ans = 0;
        for (int i = 0; i < 32; i++) {
            int andOne = 0, s1 = 0, s2 = 0;
            for (int j = 0; j < arr1.length; j++) {
                s1 += arr1[j] & 1;
                arr1[j] = arr1[j] >> 1;
            }
            for (int j = 0; j < arr2.length; j++) {
                s2 += arr2[j] & 1;
                arr2[j] = arr2[j] >> 1;
            }
            andOne = s1 * s2;
            ans |= (andOne % 2) << i;
        }
        return ans;
    }
}
//注：对于像这种需要考虑每一位的情况，那就需要拿出每一位进行额外的考虑相关的情况，也就是遍历32位
```



```java
9.图论算法
01.DFS
模板：2685. 统计完全连通分量的数量
思路：这里统计强连通分量的个数，那么这里可以看边有多少以及顶点有多少，由于是无向图，所以e=v*(v-1)/2,进行判断，因此只需要全局变量进行统计即可
class Solution {
    int e, v;

    public int countCompleteComponents(int n, int[][] edges) {
        // 使用深度优先遍历即可,由于给出的是二维数组，因此要构建图
        List<Integer>[] cnt = new List[n];
        for (int i = 0; i < n; i++)
            cnt[i] = new ArrayList<>();
        for (int i = 0; i < edges.length; i++) {
            int start = edges[i][0], end = edges[i][1];
            cnt[start].add(end);
            cnt[end].add(start);
        }
        int[] visited = new int[n];
        int ans = 0;
        for (int i = 0; i < n; i++) {
            if (visited[i] == 0) {
                v = 0;
                e = 0;
                dfs(cnt, visited, i);
                if (e == v * (v - 1))
                    ans++;
            }
        }
        return ans;
    }

    private void dfs(List<Integer>[] cnt, int[] visited, int start) {
        List<Integer> list = cnt[start];
        visited[start] = 1;
        e += list.size();
        v++;
        for (int i = 0; i < list.size(); i++) {
            if (visited[list.get(i)] == 0) {
                dfs(cnt, visited, list.get(i));
            }
        }
    }
}

02.BFS
模板：1129. 颜色交替的最短路径
思路：这里由于是交替出现的，因此这里就需要考虑两种情况，开始以红或者蓝开始，同时还需要知道当前遍历到红色还是蓝色，因此需要节点入队的时候进行保存当前节点是红色还是蓝色，如果是红色那么下一次就要是蓝色，所以就去蓝色的图中进行寻找
class Solution {
    public int[] shortestAlternatingPaths(int n, int[][] redEdges, int[][] blueEdges) {
        List<Integer>[][] grap = new List[n][2];
        for (var f : grap) {
            Arrays.setAll(f, k -> new ArrayList<>());
        }
        for (int i = 0; i < redEdges.length; i++) { // 红色：0
            grap[redEdges[i][0]][0].add(redEdges[i][1]);
        }
        for (int i = 0; i < blueEdges.length; i++) {
            grap[blueEdges[i][0]][1].add(blueEdges[i][1]);
        }
        int[][] visited = new int[n][2];
        int[] ans = new int[n];
        Arrays.fill(ans, -1);
        // 创建队列开始进bfs遍历
        Deque<int[]> queue = new ArrayDeque<>();
        // 开始把节点0入队
        queue.offer(new int[] { 0, 0 });
        queue.offer(new int[] { 0, 1 });
        int dep = 0;
        while (!queue.isEmpty()) {
            // 出队列元素
            for (int k = queue.size(); k > 0; k--) {
                var p = queue.poll();
                int i = p[0], c = p[1]; // 节点和颜色
                if (ans[i] == -1)
                    ans[i] = dep;
                visited[i][c] = 1;
                c ^= 1; // 异或颜色取反
                for (int j : grap[i][c]) {
                    if (visited[j][c] == 0) { // 没有访问过
                        queue.add(new int[] { j, c });
                    }
                }
            }
            dep++;
        }
        return ans;
    }
}

03.拓扑排序
模板：1462. 课程表 IV
思路：这里要查看的是否是前置课程，那么这里也就是拓扑排序中某些元素在当前元素前面的，因此使用拓扑排序的思想，先遍历入读为0的节点，然后让后面的元素入度--，为了后面可以判断，所以这里使用一个二维数组进行了统计，那些元素是某个元素的先驱
class Solution {
    public List<Boolean> checkIfPrerequisite(int numCourses, int[][] prerequisites, int[][] queries) {
        // 这里创建一个二维矩阵，进行判断节点之间是否存在前置条件
        List<Integer>[] grap = new List[numCourses];
        for (int i = 0; i < numCourses; i++) {
            grap[i] = new ArrayList<Integer>();
        }
        Deque<Integer> que = new ArrayDeque<>();
        List<Boolean> ans = new ArrayList<>();
        int[] indegree = new int[numCourses];
        boolean[][] isPre = new boolean[numCourses][numCourses];
        for (int i = 0; i < prerequisites.length; i++) {
            grap[prerequisites[i][0]].add(prerequisites[i][1]);
            indegree[prerequisites[i][1]]++;
        }
        for (int i = 0; i < numCourses; i++) {
            if (indegree[i] > 0)
                continue;
            que.offer(i); // 入度为0的
        }
        while (!que.isEmpty()) {
            var p = que.poll();
            for (int cur : grap[p]) {
                isPre[p][cur] = true;
                // 同时对当前节点的前面间接节点进行判断
                for (int i = 0; i < numCourses; i++) {
                    isPre[i][cur] = isPre[i][cur] || isPre[i][p];
                }
                if (--indegree[cur] == 0) {
                    // 入队
                    que.add(cur);
                }
            }
        }
        // 开始逐个判断
        for (int i = 0; i < queries.length; i++) {
            ans.add(isPre[queries[i][0]][queries[i][1]]);
        }
        return ans;
    }
}

04.基环树
模板：2359. 找到离给定两个节点最近的节点
思路：这里根据题目条件可以知，这个图有可能是个基环树，或者基环森林，那么就可以知道一颗树中最多有一个环，因此这里在遍历的时候就可以，就要考虑到环的问题；同时对于本体的思路就是剋使用广度优先遍历，从当前节点出发遍历到所有节点的距离，然后在进行去比较
class Solution {
    public int closestMeetingNode(int[] edges, int node1, int node2) {
        // 这里只需要统计这两个节点到其他所有节点的距离
        int[] d1 = calcDis(edges, node1), d2 = calcDis(edges, node2);
        int ans = -1, minDs = edges.length;
        for (int i = 0; i < edges.length; i++) {
            if (minDs > Math.max(d1[i], d2[i])) {
                ans = i;
                minDs = Math.max(d1[i], d2[i]);
            }
        }
        return ans;
    }

    private int[] calcDis(int[] edges, int node) {
        int n = edges.length;
        var res = new int[n];
        Arrays.fill(res, n);
        for (int d = 0; node >= 0 && res[node] == n; node = edges[node]) {
            res[node] = d++;
        }
        return res;
    }
}
```



```java
10.常用数据结构
01.枚举  
适用：对于需要控制多个变量的情况下可以适用枚举，同时需要适用哈希结构进行存储已经计算出来的变量，然后后面遍历到的遍历和目前的进行比较，看是否符合要求
模板：1814. 统计一个数组中好对子的数目   //枚举右，维护左
思路：对于 双变量问题，例如两数之和 𝑎𝑖+𝑎𝑗=𝑡，可以枚举右边的 𝑎𝑗，转换成 单变量问题，也就是在 𝑎𝑗左边查找是否有 𝑎𝑖=𝑡−𝑎𝑗 ，这可以用哈希表维护。 //这里对于已经遍历过的可以使用哈希表进行维护
class Solution {
    public int countNicePairs(int[] nums) {
        // 这里可以使用枚举+哈希表进行实现
        int MOD = 1_000_000_007, ans = 0;
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int cnt = map.getOrDefault(nums[i] - rev(nums[i]), 0);
            ans += cnt;
            map.put(nums[i] - rev(nums[i]), cnt + 1);
            ans = ans % MOD;
        }
        return ans;
    }

    // 数字反转
    private int rev(int num) {
        int ans = 0;
        while (num != 0) {
            ans = ans * 10 + num % 10;
            num = num / 10;
        }
        return ans;
    }
}

模板：447. 回旋镖的数量
思路：这里由于没有要求顺序同时对于I的值可能出现在中间的位置，因此就会出现多种情况，所以在枚举的时候就需要从中间的位置进行枚举，对于其他变量就要从头开始进行遍历
class Solution {
    public int numberOfBoomerangs(int[][] points) {
        // 这里就是求两条线段之间的距离和,也就是i->j i->k之间距离
        int ans = 0;
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < points.length; i++) {
            map.clear();
            for (int j = 0; j < points.length; j++) {
                int x = points[i][0] - points[j][0];
                int y = points[i][1] - points[j][1];
                int cnt = map.getOrDefault(x * x + y * y, 0);
                ans += cnt;
                map.put(x * x + y * y, cnt + 1);
            }
        }
        return ans * 2;
    }
}
```



```java
02.前缀和
适用：对于前缀和的问题，一般是要求一个区间中的数量，然后这个时候可以适用累加前缀和统计，同时对于前缀和数组一般都是创建的大小要比原本的大1，因此创建下面cnt的时候创建的是n+1的大小
模板：2055. 蜡烛之间的盘子
思路：这里适用前缀和进行统计在该元素之前，有多少个盘子，然后就可以求出某个区间盘子数量
class Solution {
    public int[] platesBetweenCandles(String s, int[][] queries) {
        // 适用前缀和进行计算，首先计算出每一个节点之前的盘子数量
        int n = s.length();
        int[] cnt = new int[n + 1];
        int[] res = new int[queries.length];
        List<Integer> list = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            if (s.charAt(i - 1) == '|')
                list.add(i - 1);
            cnt[i] = cnt[i - 1] + (s.charAt(i - 1) == '*' ? 1 : 0);
        }
        // 开始进行统计结果集
        for (int i = 0; i < queries.length; i++) {
            int left = queries[i][0], right = queries[i][1];
            // 这里适用二分查找left最右边的蜡烛，right最左边的蜡烛
            int l = -1, r = list.size();
            while (l + 1 < r) {
                int mid = l + (r - l) / 2;
                if (list.get(mid) >= left) {
                    r = mid;
                } else {
                    l = mid;
                }
            }
            if (r >= 0 && r < list.size() && list.get(r) >= left)
                left = list.get(r);
            else
                continue;
            l = -1;
            r = list.size();
            while (l + 1 < r) {
                int mid = l + (r - l) / 2;
                if (list.get(mid) <= right) {
                    l = mid;
                } else {
                    r = mid;
                }
            }
            if (l >= 0 && l < list.size() && list.get(l) <= right)
                right = list.get(l);
            else
                continue;
            if (left < right)
                res[i] = cnt[right] - cnt[left];
        }
        return res;
    }
}

模板：1546. 和为目标值且不重叠的非空子数组的最大数目
思路：这里使用哈希存储前缀和的值和索引下标，这里和作为key，这里使用了贪心进行优化，哈希中只存储最后一个出现的索引，也即是如果不同子数组前缀和相同，那么只存储最近访问的这个
//注：贪心是符合要求的，因为题目让求的是数组最小的，因此只要符合要求的最小数组那就是可以的，不用担心后面还有数组和他重合，因为后面那个更大范围，所以优先选择小的
//注：如果结合了哈希+前缀和，那么一般是不需要再用数组存储前缀和了，直接使用一个变量存储即可
class Solution {
    public int maxNonOverlapping(int[] nums, int target) {
        // 使用贪心+前缀和的方式
        Map<Integer, Integer> map = new HashMap<>();
        int ans = 0, n = nums.length, prev = -1, preSum = 0;
        map.put(0, 0);
        for (int i = 1; i <= n; i++) {
            preSum += nums[i - 1];
            // 去map中查找
            int index = map.getOrDefault(preSum - target, -1);
            if (index >= 0 && prev < index) {
                prev = i - 1;
                ans++;
            }
            map.put(preSum, i); // 这个表示这个元素之前的
        }
        return ans;
    }
}

模板：2615. 等值距离和   （前缀距离和）
思路：这里是求值相等的，因此这里可以先把相等的数据存储在一组，这样就完成了分组，分完组之后可以使用前缀和进行求解
class Solution {
    public long[] distance(int[] nums) {
        // 使用分组+前缀和方式
        Map<Integer, List<Integer>> map = new HashMap<>(); // 这里存储分组，list中存储索引
        int n = nums.length;
        // 进行分组
        for (int i = 0; i < n; i++) {
            //这里判断是否集合已经初始化了，如果没有初始化，则进行初始化，然后再返沪
            map.computeIfAbsent(nums[i], k -> new ArrayList<Integer>()).add(i);
        }
        long[] ans = new long[n];
        for (List<Integer> list : map.values()) {
            int size = list.size();
            // 开始遍历当前分组的所有元素
            long sum = 0, preSum = 0;
            for (int i = 0; i < size; i++) {
                sum += list.get(i);
            }
            for (int i = 0; i < size; i++) {
                int index = list.get(i);
                preSum += index;
                long left = (long) index * (i + 1) - preSum;
                long right = sum - preSum - (long) index * (size - i - 1);
                ans[index] = right + left;
            }
        }
        return ans;
    }
}


模板：1310. 子数组异或查询  （异或前缀和）
思路：这里使用异或和的特性
class Solution {
    public int[] xorQueries(int[] arr, int[][] queries) {
        // 异或定理 a^b^c=x a^b^c^d^e=y x^y=d^e
        int n = arr.length;
        int[] preSum = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            preSum[i] = preSum[i - 1] ^ arr[i - 1];
        }
        int[] ans = new int[queries.length];
        for (int i = 0; i < queries.length; i++) {
            int start = queries[i][0], end = queries[i][1];
            ans[i] = preSum[start] ^ preSum[end + 1];
        }
        return ans;
    }
}

模板：1895. 最大的幻方  （一维前缀和）
思路：这里只需要求出所有的前缀和，包括斜对角上的，这里需要注意的一点就是，45°斜对角是不可以出现i=1,j=-1的斜对角情况的，因此这里做了一些特殊的处理
class Solution {
    public int largestMagicSquare(int[][] grid) {
        // 这里可以求行 列 对角的前缀和
        int m = grid.length, n = grid[0].length;
        // 使用四个矩阵维护前缀和
        int[][] rowSum = new int[m][n + 1], colSum = new int[m + 1][n];
        int[][] line45 = new int[m + 1][n + 1], line135 = new int[m + 1][n + 1];
        // 开始求各个前缀和
        for (int i = 0; i < m; i++) {
            for (int j = 1; j <= n; j++) {
                rowSum[i][j] = rowSum[i][j - 1] + grid[i][j - 1];
            }
        }
        for (int j = 0; j < n; j++) {
            for (int i = 1; i <= m; i++) {
                // 这里做了一些特殊处理，当前i=1，j=0的位置表示的是i=0,j=0的前缀和
                colSum[i][j] = colSum[i - 1][j] + grid[i - 1][j];
            }
        }
        // 开始求斜对角的前缀和,45°方向
        for (int i = 1; i <= m; i++) {
            for (int j = 0; j < n; j++) {
                // System.out.println("i:"+(i-1)+",j:"+j+","+grid[i-1][j]);
                line45[i][j] = line45[i - 1][j + 1] + grid[i - 1][j];
                // System.out.println("i:"+(i)+",j:"+j+","+line45[i][j]);
            }
        }
        // 求135°方向
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                line135[i][j] = line135[i - 1][j - 1] + grid[i - 1][j - 1];
            }
        }
        // 开始判断所有的情况是否符合要求
        for (int k = Math.min(m, n); k >= 2; k--) {
            for (int i = 0; i + k - 1 < m; i++) {
                for (int j = 0; j + k - 1 < n; j++) {
                    // 判断当前是否有效
                    if (valid(i, j, k, rowSum, colSum, line45, line135)) {
                        return k;
                    }
                }
            }
        }
        return 1;
    }

    public boolean valid(int i, int j, int k, int[][] rowSum, int[][] colSum, int[][] line45, int[][] line135) {
        // 找出一个基准
        int target = line45[i + k][j] - line45[i][j + k];
        // 开始进行判断
        for (int x = i; x <= i + k - 1; x++) {
            if (target != rowSum[x][j + k] - rowSum[x][j])
                return false;
        }
        for (int x = j; x <= j + k - 1; x++) {
            if (target != colSum[i + k][x] - colSum[i][x])
                return false;
        }
        return target == (line135[i + k][j + k] - line135[i][j]);
    }
}

模板：1314. 矩阵区域和
思路：这里是二维前缀和，因此求解的时候主要是考虑边界问题，同时前缀和数组中表示的它左上方所有元素的和
class Solution {
    public int[][] matrixBlockSum(int[][] mat, int k) {
        // 二维前缀和+边界控制
        int m = mat.length, n = mat[0].length;
        // 表示在自己左上方的前缀和，所有元素的和
        int[][] sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j -1] + sum[i-1][j] + mat[i-1][j-1] - sum[i-1][j-1];
            }
        }
        // 开始求解所有元素的前缀和
        int[][] ans = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                ans[i][j] = sum[i +1 +k >= m ? m : i + k + 1][j +1 +k >= n ? n :j+k+1]
                        - sum[i - k >= 0 ? i - k : 0][j + 1 + k >= n ? n : j + k + 1]
                        - sum[i + 1 + k >= m ? m : i + k + 1][j - k >= 0 ? j - k : 0]
                        + sum[i - k >= 0 ? i - k : 0][j - k >= 0 ? j - k : 0];
            }
        }
        return ans;
    }
}
```



```java
03.差分
/*对于差分来说一般都是让求某个区间上的增量，也就是在某个区间上同时增加多少，这里就可以使用差分+前缀和的思想进行使用，在构造差分数组的时候只需要将区间的开始累加，然后超过区间右边界的第一个元素减少即可；对于差分的特性来说的话，差分数组求前缀和就可以得到原本数组的结果；对于差分数组就是后一个元素-前一个元素*/
//注：下面所有本质也都是使用了差分的思想，差分的前缀和等于原本的元素，因此我们在区间的开始+x，区间结束-x，这样求前缀和就相当于求出来了在这个区间上进行+x值的情况
模板：1109. 航班预订统计
思路：这里使用差分，差分主要是求某个区间上的增量的，他本质还是求前缀和的；差分数组对应的概念是前缀和数组，对于数组 [1,2,2,4]，其差分数组为 [1,1,0,2]，差分数组的第 i 个数即为原数组的第 i−1 个元素和第 i 个元素的差值，也就是说我们对差分数组求前缀和即可得到原数组。差分数组的性质是，当我们希望对原数组的某一个区间 [l,r] 施加一个增量inc 时，差分数组 d 对应的改变是：d[l] 增加 inc，d[r+1] 减少 inc。这样对于区间的修改就变为了对于两个位置的修改。并且这种修改是可以叠加的，即当我们多次对原数组的不同区间施加不同的增量，我们只要按规则修改差分数组即可。本题思路也是在一个区间上添加增量，但是过了这个区间就要减去增量，因此这里可以使用差分，差分思想就是前缀和减去当前元素值，因此对于结束位置我们可以把值变成负数就是减了
class Solution {
    public int[] corpFlightBookings(int[][] bookings, int n) {
        // 使用差分的思想
        int[] ans = new int[n];
        for (int[] booking : bookings) {
            ans[booking[0] - 1] += booking[2];
            if (booking[1] < n) {
                ans[booking[1]] -= booking[2];
            }
        }
        for (int i = 1; i < n; i++) {
            ans[i] += ans[i - 1];
        }
        return ans;
    }
}

模板：995. K 连续位的最小翻转次数
思路：这里还是使用差分，用一个数组进行记录需要反转的次数，如果反转的是偶数次，则相当于没有改变，奇数次相当于反转了一次
class Solution {
    public int minKBitFlips(int[] nums, int k) {
        int n = nums.length, ans = 0;
        int[] diff = new int[n + 1];
        for (int i = 0; i < n; i++) {
            if (i > 0)
                diff[i] += diff[i - 1];
            if ((diff[i] + nums[i]) % 2 == 0) {
                if (i + k > n)
                    return -1;
                ans++;
                diff[i]++;
                diff[i + k]--;
            }
        }
        return ans;
    }
}

模板:2536. 子矩阵元素加 1
思路：这里是二维差分题目，本质就是二维前缀和+差分，这里有一个关键就是把差分二维数组声明称[n+2][n+2]这样就可以在外面的数组加一圈，就不用判断数组是否越界的情况；对于二维矩阵的前缀和比较复杂，还要考虑是否越界问题，因此这里直接把矩阵扩大一圈即可
class Solution {
    public int[][] rangeAddQueries(int n, int[][] queries) {
        // 二维差分
        int[][] diff = new int[n + 2][n + 2];
        for (int[] q : queries) {
            int r1 = q[0], c1 = q[1], r2 = q[2], c2 = q[3];
            diff[r1 + 1][c1 + 1]++;
            diff[r1 + 1][c2 + 2]--;
            diff[r2 + 2][c1 + 1]--;
            diff[r2 + 2][c2 + 2]++;
        }

        // 计算 diff 的二维前缀和（原地修改），然后填入 ans
        int[][] ans = new int[n][n];
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                diff[i][j] += diff[i][j - 1] + diff[i - 1][j] - diff[i - 1][j - 1];
                ans[i - 1][j - 1] = diff[i][j];
            }
        }
        return ans;
    }
}
```



```java
04.栈
模板：2434. 使用机器人打印字典序最小的字符串   (进阶栈)
思路：这里的思路就是先记录每一个字符出现的次数，然后逐个遍历字符，判断当前栈中的字符能否出栈，出栈的前提是后面没有比他更小的字符
//注：栈的使用和队列一样，这里不创建栈，而是直接创建队列的方式进行使用，使用pop 和push进行添加删除元素
class Solution {
    public String robotWithString(String S) {
        var ans = new StringBuilder();
        var s = S.toCharArray();
        var cnt = new int[26];
        for (var c : s) ++cnt[c - 'a'];
        var min = 0; // 剩余最小字母
        var st = new ArrayDeque<Character>();
        for (var c : s) {
            --cnt[c - 'a'];
            while (min < 25 && cnt[min] == 0) ++min;
            st.push(c);
            while (!st.isEmpty() && st.peek() - 'a' <= min)
                ans.append(st.poll());
        }
        return ans.toString();
    }
}

模板：1717. 删除子字符串的最大得分    （邻项相消）
思路：这里使用贪心+栈的思想，首先移除的是最大的得分，这里转换思路只认为ab是最大的，如果x<y那就把ba换成ab也就是把a->b  b->a这样就是最大的了，因此使用栈进行存储
class Solution {
    public int maximumGain(String s, int x, int y) {
        /*
         * 使用栈+贪心的思想
         * 只考虑ab的情况，无论是x大或者y大
         */
        char[] array = s.toCharArray();
        int n = s.length(), ans = 0;
        if (x < y) {
            // "ab"<"ba" 因此要把ab ->ba
            int temp = x;
            x = y;
            y = temp;
            // 开始交换字符串中所有字符，把a b交换
            for (int i = 0; i < n; i++) {
                // 这里把所有的都修改了，包括单个存在的，但是不影响结果
                if (array[i] == 'a')
                    array[i] = 'b';
                else if (array[i] == 'b')
                    array[i] = 'a';
            }
        }
        // 开始使用栈进行求解bbaaba
        Deque<Character> st = new ArrayDeque<>();
        for (char c : array) {
            if (st.isEmpty() || st.peek() != 'a' || c != 'b') {
                st.push(c);
                continue;
            }
            ans += x;
            st.pop();
        }
        // 开始遍历栈中的所有元素,找出ba的情况累加结果 aabb
        Deque<Character> t = new ArrayDeque<>();
        while (!st.isEmpty()) {
            char c = st.pop(); // 注意这里用removeLast()保持原有顺序
            if (!t.isEmpty() && t.peek() == 'a' && c == 'b') {
                t.pop();
                ans += y;
            } else {
                t.push(c);
            }
        }
        return ans;
    }
}
```





































































